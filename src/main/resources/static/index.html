<!DOCTYPE html>
<meta charset="utf-8">

<style type="text/css">
svg {
	font-family: sans-serif;
}

rect.overlay {
	stroke: black;
}

rect.selection {
	stroke: none;
  fill: steelblue;
  fill-opacity: 0.6;
}

#labelleft, #labelright {
	dominant-baseline: hanging;
  font-size: 12px;
}

#labelleft {
	text-anchor: end;
}

#labelright {
	text-anchor: start;
}
</style>

<!-- Body tag is where we will append our SVG and SVG objects-->
<body>
  <svg id="svg1"></svg>
  <svg id="svg"></svg>
</body>

<!-- Load in the d3 library -->
<script src="/horizonchart/d3/d3.min.js" type="text/javascript"></script>

<script>

  let slider_snap = function(min, max) {

    var range = [min, max + 1]

    // set width and height of svg
    var w = 400
    var h = 60
    var margin = {top: 10,
                bottom: 135,
                left: 10,
                right: 40}

    // dimensions of slider bar
    var width = w - margin.left - margin.right;
    var height = 35;//h - margin.top - margin.bottom;

    // create x scale
    var x = d3.scaleLinear()
    .domain(range)  // data space
    .range([0, width]);  // display space

    // create svg and translated g
    var svg = d3.select("#svg1").attr("viewBox", [0, 0, w, h])

    const g = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`)

    // draw background lines
    g.append('g').selectAll('line')
    .data(d3.range(range[0], range[1]+1))
    .enter()
    .append('line')
    .attr('x1', d => x(d)).attr('x2', d => x(d))
    .attr('y1', 0).attr('y2', height)
    .style('stroke', '#ccc')

    // labels
    var labelL = g.append('text')
    .attr('id', 'labelleft')
    .attr('x', 0)
    .attr('y', height + 5)
    .text(range[0])

    var labelR = g.append('text')
    .attr('id', 'labelright')
    .attr('x', 0)
    .attr('y', height + 5)
    .text(range[1])

    // define brush
    var brush = d3.brushX()
    .extent([[0,0], [width, height]])
    .on('brush', function() {
      var s = d3.event.selection;
      // update and move labels
      labelL.attr('x', s[0])
        .text(Math.round(x.invert(s[0])))
      labelR.attr('x', s[1])
        .text(Math.round(x.invert(s[1])) - 1)
      // move brush handles
      handle.attr("display", null).attr("transform", function(d, i) { return "translate(" + [ s[i], - height / 4] + ")"; });
      // update view
      // if the view should only be updated after brushing is over,
      // move these two lines into the on('end') part below
      svg.node().value = s.map(d => Math.round(x.invert(d)));
      svg.node().dispatchEvent(new CustomEvent("input"));
    })
    .on('end', function() {
      if (!d3.event.sourceEvent) return;
      var d0 = d3.event.selection.map(x.invert);
      var d1 = d0.map(Math.round)
      d3.select(this).transition().call(d3.event.target.move, d1.map(x))
    })

    // append brush to g
    var gBrush = g.append("g")
      .attr("class", "brush")
      .call(brush)

    // add brush handles (from https://bl.ocks.org/Fil/2d43867ba1f36a05459c7113c7f6f98a)
    var brushResizePath = function(d) {
      var e = +(d.type == "e"),
          x = e ? 1 : -1,
          y = height / 2;
      return "M" + (.5 * x) + "," + y + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6) + "V" + (2 * y - 6) +
        "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y) + "Z" + "M" + (2.5 * x) + "," + (y + 8) + "V" + (2 * y - 8) +
        "M" + (4.5 * x) + "," + (y + 8) + "V" + (2 * y - 8);
    }

    var handle = gBrush.selectAll(".handle--custom")
    .data([{type: "w"}, {type: "e"}])
    .enter().append("path")
    .attr("class", "handle--custom")
    .attr("stroke", "#000")
    .attr("fill", '#eee')
    .attr("cursor", "ew-resize")
    .attr("d", brushResizePath);

    // override default behaviour - clicking outside of the selected area
    // will select a small piece there rather than deselecting everything
    // https://bl.ocks.org/mbostock/6498000
    gBrush.selectAll(".overlay")
    .each(function(d) { d.type = "selection"; })
    .on("mousedown touchstart", brushcentered)

    function brushcentered() {
    var dx = x(1) - x(0), // Use a fixed width when recentering.
    cx = d3.mouse(this)[0],
    x0 = cx - dx / 2,
    x1 = cx + dx / 2;
    d3.select(this.parentNode).call(brush.move, x1 > width ? [width - dx, width] : x0 < 0 ? [0, dx] : [x0, x1]);
    }

    // select entire range
    gBrush.call(brush.move, range.map(x))

    return svg.node()
  }


  function ISO8601_week_no(dt) {
    var tdt = new Date(dt.valueOf());
    var dayn = (dt.getDay() + 6) % 7;
    tdt.setDate(tdt.getDate() - dayn + 3);
    var firstThursday = tdt.valueOf();
    tdt.setMonth(0, 1);
    if (tdt.getDay() !== 4) {
        tdt.setMonth(0, 1 + ((4 - tdt.getDay()) + 7) % 7);
    }
    return 1 + Math.ceil((firstThursday - tdt) / 604800000);
  }

  function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  }

  function getLastDayOfWeek(date){
    var dayNo = date.getDay();
    var year = date.getYear();
    if(dayNo == 0)//Sunday
      return date;
    else{
      var newDate = addDays(date,7-dayNo);
      if(year != newDate.getYear()){
        return new Date(year+1900, 12-1, 31);
      }
      else
        return newDate;
    }
  }

  var anhos = "2015"
  var ageRange = [0,101]

  let data2015;
  let data2016;
  let data2017;
  let data2018;
  let data2019;
  async function loadData(){
    data2015 = (await d3.csv("https://raw.githubusercontent.com/hpuentes/homicidios-en-colombia/master/Homicidios_2015.csv", ({date, depto, age}) => {var dateParts = date.split("/");
      var year = +dateParts[2];
      if(year < 2000)
        year = year + 2000;
      var dateObject = new Date(year, dateParts[0] - 1, +dateParts[1]);
      var weekNo = ISO8601_week_no(dateObject);
      var dayNo = dateObject.getDay();
      var lastDayOfWeek = getLastDayOfWeek(dateObject);
      var millis = lastDayOfWeek.getTime();
      return {date:dateObject, depto: depto,age:+age,week:weekNo,day:dayNo,lastDayOfWeek:millis};
    }));

    data2016 = (await d3.csv("https://raw.githubusercontent.com/hpuentes/homicidios-en-colombia/master/Homicidios_2016.csv", ({date, depto, age}) => {var dateParts = date.split("/");
      var year = +dateParts[2];
      if(year < 2000)
        year = year + 2000;
      var dateObject = new Date(year, dateParts[0] - 1, +dateParts[1]);
      var weekNo = ISO8601_week_no(dateObject);
      var lastDayOfWeek = getLastDayOfWeek(dateObject);
      var millis = lastDayOfWeek.getTime();
      return {date:dateObject, depto: depto,age:+age, week:weekNo,lastDayOfWeek:millis};
    }));

    data2017 = (await d3.csv("https://raw.githubusercontent.com/hpuentes/homicidios-en-colombia/master/Homicidios_2017.csv", ({date, depto, age}) => {var dateParts = date.split("/");
      var year = +dateParts[2];
      if(year < 2000)
        year = year + 2000;
      var dateObject = new Date(year, dateParts[1] - 1, +dateParts[0]);
      var weekNo = ISO8601_week_no(dateObject);
      var lastDayOfWeek = getLastDayOfWeek(dateObject);
      var millis = lastDayOfWeek.getTime();
      return {date:dateObject, depto: depto,age:+age, week: weekNo,lastDayOfWeek:millis};
    }));

    data2018 = (await d3.csv("https://raw.githubusercontent.com/hpuentes/homicidios-en-colombia/master/Homicidios_2018.csv", ({date, depto, age}) => {var dateParts = date.split("/");
      var year = +dateParts[2];
      if(year < 2000)
        year = year + 2000;
      var dateObject = new Date(year, dateParts[1] - 1, +dateParts[0]);
      var weekNo = ISO8601_week_no(dateObject);
      var lastDayOfWeek = getLastDayOfWeek(dateObject);
      var millis = lastDayOfWeek.getTime();
      return {date:dateObject, depto: depto,age:+age,week:weekNo,lastDayOfWeek:millis};
    }));

    data2019 = (await d3.csv("https://raw.githubusercontent.com/hpuentes/homicidios-en-colombia/master/Homicidios_2019.csv", ({date, depto, age}) => {var dateParts = date.split("/");
      var year = +dateParts[2];
      if(year < 2000)
        year = year + 2000;
      var dateObject = new Date(year, dateParts[1] - 1, +dateParts[0]);
      var weekNo = ISO8601_week_no(dateObject);
      var lastDayOfWeek = getLastDayOfWeek(dateObject);
      var millis = lastDayOfWeek.getTime();
      return {date:dateObject, depto: depto,age:+age,week:weekNo,lastDayOfWeek:millis};
    }));

    load();
  }
  loadData();

  function load(){
    let width = 800;

    let dataAhnos;
    if(anhos == "2015")
      dataAhnos = data2015;
    else if(anhos == "2016")
      dataAhnos = data2016;
    else if(anhos == "2017")
      dataAhnos = data2017;
    else if(anhos == "2018")
      dataAhnos = data2018;
    else if(anhos == "2019")
      dataAhnos = data2019;

    let dataAhnosFilter = d3.entries(dataAhnos).filter((value, index, arr) => {
        if(typeof value.value.date === 'undefined'){
          return false;
        }
        var year = value.value.date.getYear()+1900;
        if(year+"" != anhos){
          console.log("error "+year+" "+anhos+" "+value.value.date)
          return false;
        }
        return value.value.age >= ageRange[0] && value.value.age < ageRange[1];
    }).map(d => {
      return {
        date: d.value.lastDayOfWeek,
        name: d.value.depto
      }
    });

    var dataHorizon = d3.nest()
     .key(d => { return d.name+"-"+d.date; })
     .rollup(v => { return v.length; })
     .entries(dataAhnosFilter)
     .map(group => {
        var depto = group.key.substring(0,group.key.indexOf("-"));
        var millis = group.key.substring(group.key.indexOf("-")+1,group.key.length);
        var lastDay = new Date(+millis);
        return {
          name: depto,
          date: lastDay,
          value: group.value
        }
     });

    let data = d3.nest()
      .key(d => d.name)
      .sortValues((a, b) => a.date - b.date)
    .entries(dataHorizon)
    .map(d => (d.sum = d3.sum(d.values, d => d.value), d))
    .sort((a, b) => b.sum - a.sum);

    let step = 23;
    let margin = ({top: 30, right: 10, bottom: 0, left: 10})
    let height = data.length * (step + 1) + margin.top + margin.bottom
    let overlap = 9;
    let scheme = "schemeReds";
    let color = i => d3[scheme][Math.max(3, overlap)][i + Math.max(0, 3 - overlap)]

    let x = d3.scaleUtc()
      .domain([data[0].values[0].date, data[0].values[data[0].values.length - 1].date])
      .range([0, width])

    let xAxis = g => g
      .attr("transform", `translate(0,${margin.top})`)
      .call(d3.axisTop(x).ticks(width / 80).tickSizeOuter(0))
      .call(g => g.selectAll(".tick").filter(d => x(d) < margin.left || x(d) >= width - margin.right).remove())
      .call(g => g.select(".domain").remove())

    let y = d3.scaleLinear()
      .domain([0, d3.max(data, d => d3.max(d.values, d => d.value))])
      .range([0, -overlap * step])

    let area = d3.area()
      .curve(d3.curveBasis)
      .defined(d => !isNaN(d.value))
      .x(d => x(d.date))
      .y0(0)
      .y1(d => y(d.value))

    const svg = d3.select("#svg")
        .attr("viewBox", [0, 0, width, height])
        .style("font", "10px sans-serif");

    const g = svg.append("g")
      .selectAll("g")
      .data(data)
      .join("g")
        .attr("transform", (d, i) => `translate(0,${i * (step + 1) + margin.top})`);

    var customIDCntr = 0;

    function getNextID(customIDprefix) {
      var id = customIDprefix + customIDCntr++;
      return {id : id, href: "http://localhost:8080/horizonchart/index.html#"+id};
    }

    g.append("clipPath")
        .attr("id", d => (d.clip = getNextID("clip")).id)
      .append("rect")
        .attr("width", width)
        .attr("height", step);

    g.append("defs").append("path")
        .attr("id", d => (d.path = getNextID("path")).id)
        .attr("d", d => area(d.values));

    g.append("g")
        .attr("clip-path", d => d.clip)
      .selectAll("use")
      .data(d => new Array(overlap).fill(d))
      .join("use")
        .attr("fill", (d, i) => color(i))
        .attr("transform", (d, i) => `translate(0,${(i + 1) * step})`)
        .attr("xlink:href", d => {console.log(d); return d.path.href;});

    g.append("text")
        .attr("x", 4)
        .attr("y", step / 2)
        .attr("dy", "0.35em")
        .text(d => d.key);

    svg.append("g")
        .call(xAxis);

  }

</script>
